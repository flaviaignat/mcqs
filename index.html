<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>quiz.practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- favicon: kills the /favicon.ico 404 -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='18' fill='%232563eb'/><text x='50' y='62' text-anchor='middle' font-size='58' fill='white'>Q</text></svg>">

  <style>
    :root{--border:#e5e7eb;--primary:#2563eb;--muted:#6b7280}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111827}
   header{position:sticky;top:0;z-index:10;display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-bottom:1px solid var(--border);background:#fff}
    main{max-width:900px;margin:16px auto;padding:0 16px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input[type="search"]{padding:10px 12px;border:1px solid var(--border);border-radius:10px;min-width:260px;flex:1}
    .btn, .btn-link{display:inline-block;padding:10px 14px;border:1px solid var(--border);border-radius:10px;background:#f3f4f6;text-decoration:none;color:inherit}
    .btn:hover,.btn-link:hover{background:#e5e7eb}
    .primary{background:var(--primary);color:#fff;border-color:#1d4ed8}
    .primary:hover{background:#1d4ed8}
    .card{border:1px solid var(--border);border-radius:12px;padding:16px;margin-top:12px}
    .option{display:flex;gap:10px;align-items:flex-start;margin:6px 0}
    .checkbox{transform:translateY(2px)}
    .muted{color:var(--muted)}
    .flag{color:#dc2626;font-size:12px;margin-left:6px}
    .feedback{margin-top:8px;font-size:14px}
    .feedback.correct{color:#10b981;font-weight:600}
    .feedback.wrong{color:#dc2626;font-weight:600}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .nav-links{display:flex;gap:8px}
    footer{margin-top:18px;color:var(--muted);font-size:12px}
    .pill {
  display:inline-block;
  padding:2px 8px;
  border:1px solid var(--border);
  border-radius:999px;
  font-size:12px;
  margin-left:6px;
}
.pill.attempted {
  background:#ecfdf5;
  border-color:#10b981;
  color:#065f46;
  font-weight:600;
}
#siteCounters { margin-left:12px; }
/* Temporarily hide editing controls */
.edit-btn, 
#toggle-edits,
#addQBtn,
#newQ {
  display: none !important;
}
  </style>
</head>
<body>
  <header>
  <strong>quiz.practice</strong>
  <span id="siteCounters" class="muted"></span>
</header>


  <main>
    <!-- Filters / Nav -->
    <div class="row">
      <a id="showUnattempted" href="#" class="btn-link">Unattempted</a>
      <input id="search" type="search" placeholder="Search in question text..." />
      <a href="./topics.html" class="btn-link">Topics</a>
      <a href="./review_all.html" class="btn-link">Review All</a>
      <a id="showReview" href="#" class="btn-link">My Review (‚≠ê + üö©)</a>
      <a id="showAll" href="#" class="btn-link">All Questions</a>
      <button id="applySearch" class="btn">Search</button>
      <button id="clearSearch" class="btn">Clear</button>
      <!-- Added shuffle and start-from-end buttons -->
      <button id="shuffleBtn" class="btn">Shuffle</button>
      <button id="startEndBtn" class="btn">Start from End</button>
    </div>

    <!-- Quiz card -->
    <div class="card">
      <p class="qtitle" id="qtitle">Loading‚Ä¶</p>
      <div id="options"></div>

      <div class="controls">
        <button id="checkBtn" class="btn primary">Check</button>
        <button id="flagBtn" class="btn">Flag for Review</button>
        <button id="continueBtn" class="btn" disabled>Continue</button>
        <button id="showAnsBtn" class="btn">Reveal Answer</button>

        <button id="editBtn" class="btn">Edit</button>
        <button id="addQBtn" class="btn">Add Question</button>

        <button id="exportBtn" class="btn">Export Corrections</button>
        <button id="reviewWrongBtn" class="btn">Review Wrong</button>
        <button id="showAllBtn" class="btn">All Questions</button>
        <button id="clearFlagsBtn" class="btn">Clear Flags</button>
        <button id="reportBtn" class="btn">Report Error</button>
      </div>

      <div id="feedback" class="feedback"></div>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <button id="prevBtn" class="btn">‚óÄ Prev</button>
        <div class="muted" id="progress">0 of 0</div>
        <button id="nextBtn" class="btn">Next ‚ñ∂</button>
      </div>
    </div>

    <footer class="muted">Tip: ‚ÄúSave For Later‚Äù stores your current selection locally on this device. 
    To continue, press check and then press continue. If answered correctly, then the question won't be flagged.
    If answered incorrectly, then question will be flagged. Manually flag questions unsure about. </footer>
  </main>

  <script>
    // ---- Debug banner ----
(function(){
  const box = document.createElement('pre');
  box.id = 'dbg';
  box.style.cssText = 'white-space:pre-wrap;background:#0b1020;color:#a7ffb1;padding:10px;border-radius:8px;margin:10px 16px;display:none';
  document.body.insertBefore(box, document.body.firstChild.nextSibling); // under header
  function log(...a){ box.style.display='block'; console.log(...a); box.textContent += (box.textContent ? '\n' : '') + a.map(x=>String(x)).join(' '); }
  window.addEventListener('error', e => log('JS error:', e.message, '@', (e.filename||'').split('/').pop()+':'+e.lineno));
  window.dbg = log;
})();

  // ---------- Helpers ----------
  function bind(id, ev, fn){
    const el = document.getElementById(id);
    if (el) el.addEventListener(ev, fn);
  }
  function setFeedback(msg, cls=''){
    const box = document.getElementById('feedback');
    if (!box) return;
    box.textContent = msg || '';
    box.className = cls ? `feedback ${cls}` : 'feedback';
  }
  function isFlagged(id){ return Array.isArray(wrong) && wrong.includes(id); }
  function flagWrong(id){ if(!Array.isArray(wrong)) wrong=[]; if(!wrong.includes(id)){ wrong.push(id); localStorage.setItem('wrong_ids', JSON.stringify(wrong)); } }
  function unflagWrong(id){ if(!Array.isArray(wrong)) return; wrong = wrong.filter(x=>x!==id); localStorage.setItem('wrong_ids', JSON.stringify(wrong)); }

  // ---------- State ----------
  let edits = JSON.parse(localStorage.getItem('edits') || '{}');
  let added = JSON.parse(localStorage.getItem('added_questions') || '[]');
  let wrong = JSON.parse(localStorage.getItem('wrong_ids') || '[]');
  let flaggedByUser = JSON.parse(localStorage.getItem('user_flags') || '[]');
  let selections = JSON.parse(localStorage.getItem('mcqSelections') || '{}');
let attempted = JSON.parse(localStorage.getItem('attempted_ids') || '[]');

function isAttempted(id){
  // Attempted if we've recorded it OR you have a saved selection for it
  return attempted.includes(id) || !!(selections[id] && selections[id].length);
}
function markAttempted(id){
  if (!attempted.includes(id)){
    attempted.push(id);
    localStorage.setItem('attempted_ids', JSON.stringify(attempted));
  }
}

  let ALL = [];
  let QUESTIONS = [];
  let idx = 0;
  let filterMode = 'all'; // 'all' | 'review' | 'unattempted'

  function mergeAdded(){
    if (!Array.isArray(added) || added.length===0) return ALL.slice();
    const byId = new Map(ALL.map(q=>[q.id,q]));
    for (const q of added) byId.set(q.id, q);
    return Array.from(byId.values());
  }

function getViewSet(){
  if (filterMode === 'review'){
    const need = new Set([...(wrong||[]), ...(flaggedByUser||[])]);
    return QUESTIONS.filter(q => need.has(q.id));
  }
  if (filterMode === 'unattempted'){
    return QUESTIONS.filter(q => !isAttempted(q.id));
  }
  return QUESTIONS; // 'all'
}
// add this right after getViewSet()
function updateCounters(){
  const all = mergeAdded();                 // full bank (incl. added)
  const total = all.length;
  const attemptedCount = all.filter(q => isAttempted(q.id)).length;
  const left = total - attemptedCount;
  const el = document.getElementById('siteCounters');
  if (el) el.textContent = `${total} total ‚Ä¢ ${attemptedCount} attempted ‚Ä¢ ${left} left`;
}

  // ---------- Render ----------
  function render(){
    const VIEW = getViewSet();
if (VIEW.length === 0){
  const msg =
    (filterMode === 'review')       ? 'No questions are flagged yet (‚≠ê or üö©).'
  : (filterMode === 'unattempted')  ? 'All questions have been attempted üéâ'
                                    : 'No questions match.';
  document.getElementById('qtitle').textContent = msg;
  document.getElementById('options').innerHTML = '';
  document.getElementById('progress').textContent = '0 of 0';
  document.getElementById('continueBtn').disabled = true;
  return;
}


    if (idx >= VIEW.length) idx = VIEW.length - 1;
    if (idx < 0) idx = 0;

    const q = VIEW[idx];

    const flagged = isFlagged(q.id) ? ' üö©' : '';
    const star = flaggedByUser.includes(q.id) ? ' ‚≠ê' : '';
    const attemptedBadge = isAttempted(q.id) ? '<span class="pill attempted">Attempted</span>' : '';
document.getElementById('qtitle').innerHTML = `${q.id}${flagged}${star}  ${q.stem} ${attemptedBadge}`;


    const optWrap = document.getElementById('options');
    optWrap.innerHTML = '';
    (q.options || []).forEach(opt => {
      const label = document.createElement('label');
      label.className = 'option';
      const input = document.createElement('input');
      input.type = (q.type === 'single') ? 'radio' : 'checkbox';
      input.name = 'opts';
      input.value = opt.key;
      input.className = 'checkbox';
      const saved = selections[q.id] || [];
      if(saved.includes(opt.key)) input.checked = true;
      label.appendChild(input);
      label.appendChild(document.createTextNode(` ${opt.key}. ${opt.text}`));
      optWrap.appendChild(label);
    });

    document.getElementById('progress').textContent = `${idx+1} of ${VIEW.length}`;
    setFeedback('');
    document.getElementById('continueBtn').disabled = true;
    updateCounters();
  }

  // ---------- Search ----------
  let t = null;
  function runSearchFilter(){
    const qStr = (document.getElementById('search')?.value || '').trim().toLowerCase();
    const merged = mergeAdded(); // include added questions
    if(!qStr){ QUESTIONS = merged; idx = 0; render(); return; }
    QUESTIONS = merged.filter(item => {
      const stem = (item.stem || '').toLowerCase();
      const optsText = Array.isArray(item.options)
        ? item.options.map(o=>o.text).join(' ').toLowerCase()
        : Object.values(item.options||{}).join(' ').toLowerCase();
      return (stem + ' ' + optsText).includes(qStr);
    });
    idx = 0; render();
  }

  // ---------- Event listeners block ----------
  // Search (debounced typing)
  bind('search','input', () => {
    clearTimeout(t);
    t = setTimeout(runSearchFilter, 150);
  });
  // Search button
  bind('applySearch','click', runSearchFilter);
  // Clear search
  bind('clearSearch','click', () => {
    const s = document.getElementById('search'); if (s) s.value = '';
    runSearchFilter();
  });

  // My Review / All
bind('showReview','click', (e) => { e.preventDefault(); filterMode = 'review';      idx = 0; render(); });
bind('showUnattempted','click', (e) => { e.preventDefault(); filterMode = 'unattempted'; idx = 0; render(); });
bind('showAll','click', (e) => { e.preventDefault(); filterMode = 'all';         idx = 0; render(); });


  // Check
  bind('checkBtn','click', () => {
    const VIEW = getViewSet();
    const q = VIEW[idx]; 
    if (!q) return;  
    markAttempted(q.id);

    const selected = Array.from(document.querySelectorAll('input[name="opts"]:checked')).map(i=>i.value).sort();
    const correct = Array.isArray(q.correct) ? [...q.correct].sort() : String(q.correct||'').split(/[,\s]+/).filter(Boolean).sort();
    if (JSON.stringify(selected) === JSON.stringify(correct)) {
      setFeedback('‚úÖ Correct!', 'correct');
      document.getElementById('continueBtn').disabled = false;
      unflagWrong(q.id);
      document.getElementById('qtitle').textContent = `${q.id}${flaggedByUser.includes(q.id)?' ‚≠ê':''}  ${q.stem}`;
    } else {
      setFeedback('‚ùå Try again', 'wrong');
      flagWrong(q.id);
      document.getElementById('qtitle').textContent = `${q.id} üö©${flaggedByUser.includes(q.id)?' ‚≠ê':''}  ${q.stem}`;
    }
  });

  // ‚≠ê Flag for Review
  bind('flagBtn','click', () => {
    const VIEW = getViewSet();
    const q = VIEW[idx]; if (!q) return;
    if (!flaggedByUser.includes(q.id)) {
      flaggedByUser.push(q.id);
      setFeedback('‚≠ê Added to My Review');
    } else {
      flaggedByUser = flaggedByUser.filter(id => id !== q.id);
      setFeedback('‚≠ê Removed from My Review');
    }
    localStorage.setItem('user_flags', JSON.stringify(flaggedByUser));
    render();
  });

  // Reveal Answer (robust + fallback to base bank)
bind('showAnsBtn','click', () => {
  const VIEW = getViewSet();
  const q = VIEW[idx];
  if (!q) return;

  // Prefer current question.correct, else fall back to the base item from ALL
  const base = ALL.find(item => item && item.id === q.id);
  let corr = q?.correct ?? base?.correct ?? null;

  // Normalize to array of letters
  if (Array.isArray(corr)) {
    corr = corr.map(s => String(s).trim().toLowerCase()).filter(Boolean);
  } else if (typeof corr === 'string') {
    corr = corr.split(/[,\s]+/).map(s => s.trim().toLowerCase()).filter(Boolean);
  }

  if (!corr || corr.length === 0) {
    setFeedback('No correct answer stored for this question.', 'wrong');
    return;
  }
  setFeedback('Answer: ' + corr.join(', '), 'correct');
});

  // Navigation
  function goNext(){ const VIEW = getViewSet(); if(idx < VIEW.length-1){ idx++; render(); } }
  bind('continueBtn','click', goNext);
  bind('prevBtn','click', () => { if(idx>0){ idx--; render(); } });
  bind('nextBtn','click', goNext);

  // Review only üö© wrong
  bind('reviewWrongBtn','click', () => {
    const set = new Set(wrong||[]);
    if (set.size === 0){ setFeedback('No flagged questions yet.', ''); return; }
    QUESTIONS = mergeAdded().filter(q => set.has(q.id));
    idx = 0; filterReviewOnly = false; render();
    setFeedback(`Reviewing ${QUESTIONS.length} flagged question(s).`, '');
  });

  // Back to full set
  bind('showAllBtn','click', () => {
    QUESTIONS = mergeAdded(); idx = 0; filterReviewOnly = false; render();
    setFeedback('Showing all questions.', '');
  });

  // Shuffle all questions randomly
  bind('shuffleBtn','click', () => {
    // Merge added to ensure custom questions are included
    const merged = mergeAdded();
    // Fisher-Yates shuffle
    for (let i = merged.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [merged[i], merged[j]] = [merged[j], merged[i]];
    }
    QUESTIONS = merged;
    idx = 0;
    filterMode = 'all';
    setFeedback('Questions shuffled.', '');
    render();
  });

  // Start from the last question in the current view
  bind('startEndBtn','click', () => {
    const view = getViewSet();
    if (view.length === 0) return;
    idx = view.length - 1;
    setFeedback('Starting from last question.', '');
    render();
  });

  // Clear all üö© flags
  bind('clearFlagsBtn','click', () => {
    if (!wrong || wrong.length===0){ setFeedback('No flags to clear.', ''); return; }
    if (!confirm(`Clear ${wrong.length} flagged question(s)?`)) return;
    wrong = []; localStorage.setItem('wrong_ids', JSON.stringify(wrong));
    setFeedback('All flags cleared.', ''); render();
  });

// ---------- Data load ----------
fetch('./all_ques_checked.json?v=20250903', { cache: 'no-store' })
  .then(r => {
    dbg('fetch status', r.status);
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return r.json();
  })
  .then(raw => {
    // Inspect structure
    const keys = raw && typeof raw === 'object' && !Array.isArray(raw) ? Object.keys(raw) : [];
    dbg('json type', Array.isArray(raw) ? 'array' : typeof raw, 'keys', keys.join(',') || '-');

    // Adapt to either array or {questions:[...]} or {items:[...]}
ALL = Array.isArray(raw) ? raw : (raw.questions ?? raw.items ?? []);
QUESTIONS = ALL.slice();
idx = 0;

dbg('json length', ALL.length);

// üîç Audit for missing/empty correct
(function audit() {
  const bad = (ALL || []).filter(x => !x || !x.correct ||
               (Array.isArray(x.correct) && x.correct.length === 0));
  if (bad.length) dbg('Missing/empty correct for IDs:', bad.map(x => x.id).join(', '));
})();
        
render();

  })
  .catch(err => {
    console.error('Failed to load questions:', err);
    dbg('load fail:', err && err.message ? err.message : String(err));
    const title = document.getElementById('qtitle');
    if (title) title.textContent = 'Failed to load questions.';
  });


  </script>
</body>
</html>

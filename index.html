<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MCQ Practice</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='18' fill='%232563eb'/><text x='50' y='62' text-anchor='middle' font-size='58' fill='white'>Q</text></svg>">

<style>
  :root{
    --bg:#ffffff; --card:#ffffff; --border:#d9d9d9; --text:#1f2937; --muted:#6b7280; --primary:#2563eb; --btn:#f3f4f6;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text);}
  header{position:sticky;top:0;z-index:10;display:flex;align-items:center;justify-content:space-between;padding:10px 16px;border-bottom:1px solid var(--border);background:#fff;}
  header .status{display:flex;align-items:center;gap:10px;font-size:14px;color:var(--muted);}
  header .url{max-width:65%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#6b7280}
  main{max-width:760px;margin:24px auto 96px;padding:0 16px;}
  .card{border:1px solid var(--border);border-radius:12px;padding:18px;background:var(--card);}
  .qtitle{font-weight:600;margin:0 0 10px 0}
  .option{display:block;margin:8px 0;font-size:15px;line-height:1.35;}
  .controls{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap}
  button{border:1px solid var(--border);background:var(--btn);padding:8px 14px;border-radius:8px;font-size:14px;cursor:pointer;}
  button.primary{background:#2563eb;color:#fff;border-color:#1d4ed8}
  button:disabled{opacity:.5;cursor:not-allowed}
  .progress{margin-top:10px;color:var(--muted);font-size:14px}
  .feedback{margin-top:8px;font-weight:600}
  .correct{color:#16a34a}
  .wrong{color:#dc2626}
  .footer{position:fixed;bottom:0;left:0;right:0;display:flex;justify-content:center;padding:14px;background:linear-gradient(to top, rgba(255,255,255,0.95), rgba(255,255,255,0.8));border-top:1px solid var(--border);gap:10px;}
  .footer button{min-width:120px}
  .nav{display:flex;align-items:center;gap:8px;margin-top:14px;color:var(--muted);font-size:14px}
  .divider{flex:1}
  .hint{font-size:13px;color:var(--muted);margin-top:4px}
  .checkbox{transform:scale(1.1);margin-right:8px}
  .filters{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 12px 0}
  .filters input{padding:8px;border:1px solid var(--border);border-radius:8px;width:100%;max-width:320px}
  .btn-link {
  display:inline-block;
  padding:10px 14px;
  border:1px solid var(--border);
  border-radius:10px;
  background:#f3f4f6;
  color:inherit;
  text-decoration:none;
  margin-right:8px;
}
.btn-link:hover {
  background:#e5e7eb;
}

</style>
</head>
<body>
<header>
  <div class="status">
    <span id="clock">--:--</span>
    <span aria-hidden="true">üîï</span>
  </div>
  <div class="url">quiz.practice</div>
  <div style="width:24px"></div>
</header>

<main>
  <div class="filters">
    <input id="search" placeholder="Search in question text..." />
     <a href="./topics.html" class="btn-link">Topics</a>
<a href="./review_all.html" class="btn-link">Review All</a>
    <a href="#" id="showReview" class="btn-link">My Review (‚≠ê+üö©)</a>
<a href="#" id="showAll" class="btn-link">All Questions</a>

    <button id="applySearch">Search</button>
    <button id="clearSearch">Clear</button>
  </div>
  <div class="card">
    <p class="qtitle" id="qtitle"></p>
    <div id="options"></div>
    <div style="margin-top:12px;">


</div>

    <div class="controls">
      <button id="checkBtn" class="primary">Check</button>
      <button id="flagBtn">Flag for Review</button>
      <button id="continueBtn" disabled>Continue</button>
      
      <button id="showAnsBtn">Reveal Answer</button>
      
      <button id="editBtn">Edit</button>
      <button id="addQBtn">Add Question</button>
      <button id="exportBtn">Export Corrections</button>
      <button id="reviewWrongBtn">Review Wrong</button>
      <button id="showAllBtn">All Questions</button>
      <button id="clearFlagsBtn">Clear Flags</button>
      <button id="reportBtn">Report Error</button>
    </div>
    <div class="feedback" id="feedback"></div>
    <div class="progress" id="progress"></div>
  </div>
<div id="editor" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
  <label>Stem:<br><textarea id="editStem" style="width:100%; height:60px;"></textarea></label><br><br><label>Type:<br>
  <select id="editType" style="width:100%;">
    <option value="single">single (one correct)</option>
    <option value="multi">multi (multiple correct)</option>
  </select>
</label><br><br>

  <label>Options:<br><textarea id="editOptions" style="width:100%; height:100px;"></textarea></label><br><br>
  <label>Correct answers (letters, comma-separated):<br>
    <input id="editCorrect" style="width:100%;" />
  </label><br><br>
  <button id="saveEditBtn">Save Changes</button>
  <button id="cancelEditBtn">Cancel</button>
</div>
  <div id="newQ" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
  <h4>Add New Question</h4>
  <label>Question ID (e.g., XII.110):<br>
    <input id="newQId" style="width:100%;" />
  </label><br><br>

  <label>Stem:<br>
    <textarea id="newQStem" style="width:100%; height:60px;"></textarea>
  </label><br><br>

  <label>Type:<br>
    <select id="newQType" style="width:100%;">
      <option value="single">single (one correct)</option>
      <option value="multi">multi (multiple correct)</option>
    </select>
  </label><br><br>

  <label>Options (one per line, like ‚Äúa. text‚Äù, ‚Äúb. text‚Äù‚Ä¶):<br>
    <textarea id="newQOptions" style="width:100%; height:120px;"></textarea>
  </label><br><br>

  <label>Correct answers (letters, comma-separated; e.g., ‚Äúc‚Äù or ‚Äúa,c,e‚Äù):<br>
    <input id="newQCorrect" style="width:100%;" />
  </label><br><br>

  <button id="saveNewQBtn">Save Question</button>
  <button id="cancelNewQBtn">Cancel</button>
</div>
  <div class="nav">
    <button id="prevBtn">‚óÄÔ∏é Prev</button>
    <div class="divider"></div>
    <button id="nextBtn">Next ‚ñ∂Ô∏é</button>
  </div>
  <p class="hint">Tip: ‚ÄúSave For Later‚Äù stores your current selection locally on this device.</p>
</main>

<div class="footer" role="toolbar" aria-label="Bottom actions">
  <button id="jumpStartBtn">Jump to start</button>
  <button id="jumpEndBtn">Jump to end</button>
</div>

<script>
function bind(id, ev, fn){
  const el = document.getElementById(id);
  if (el) el.addEventListener(ev, fn);
}

let ALL = [];
let QUESTIONS = [];
let idx = 0;
const selections = loadSelections();
// ---- Wrong-answers flags (shared with stems_and_options page) ----
let wrong = JSON.parse(localStorage.getItem('wrong_ids') || '[]');
let filterReviewOnly = false;   // show only flagged/wrong when true

function getViewSet(){
  if (!filterReviewOnly) return QUESTIONS;
  const needIds = new Set([
    ...wrong,                     // üö© wrong by site
    ...flaggedByUser              // ‚≠ê your own marks
  ]);
  return QUESTIONS.filter(q => needIds.has(q.id));
}

let flaggedByUser = JSON.parse(localStorage.getItem('user_flags') || '[]');

function isFlagged(id){ return Array.isArray(wrong) && wrong.includes(id); }
function flagWrong(id){
  if(!Array.isArray(wrong)) wrong = [];
  if(!wrong.includes(id)) wrong.push(id);
  localStorage.setItem('wrong_ids', JSON.stringify(wrong));
}
function unflagWrong(id){
  if(!Array.isArray(wrong)) return;
  wrong = wrong.filter(x => x !== id);
  localStorage.setItem('wrong_ids', JSON.stringify(wrong));
}

// --- JSON loader (robust) ---
fetch('./all_ques_checked.json?v=20250903', { cache: 'no-store' })
  .then(r => {
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return r.json();
  })
  .then(raw => {
    // Accept either an array or an object {questions:[...]}
    ALL = Array.isArray(raw) ? raw : (raw.questions ?? raw.items ?? []);
    QUESTIONS = ALL.slice();
    idx = 0;
    // clear any stale status message if you set one earlier
    const title = document.getElementById('qtitle');
    if (title && /^Failed to load/.test(title.textContent)) title.textContent = '';
    render();
  })
  .catch(err => {
    console.error('Failed to load questions:', err);
    const title = document.getElementById('qtitle');
    if (title) title.textContent = 'Failed to load questions.';
  });


// --- Event listeners block ---
let t = null;

// Search box (debounced) ‚Äî uses #search
bind('search','input', () => {
  clearTimeout(t);
  t = setTimeout(runSearchFilter, 150);
});

function render(){
  const VIEW = getViewSet();
  if (VIEW.length === 0){
    document.getElementById('qtitle').textContent = filterReviewOnly
      ? 'No questions are flagged yet (‚≠ê or üö©).'
      : 'No questions match.';
    document.getElementById('options').innerHTML = '';
    document.getElementById('progress').textContent = '0 of 0';
    return;
  }

  // keep idx in bounds after filters/search
  if (idx >= VIEW.length) idx = VIEW.length - 1;
  if (idx < 0) idx = 0;

  const q = VIEW[idx];

  const flagged = isFlagged(q.id) ? ' üö©' : '';
  const star = flaggedByUser.includes(q.id) ? ' ‚≠ê' : '';
  document.getElementById('qtitle').textContent = `${q.id}${flagged}${star}  ${q.stem}`;

  const optWrap = document.getElementById('options');
  optWrap.innerHTML = '';
  q.options.forEach(opt => {
    const label = document.createElement('label');
    label.className = 'option';
    const input = document.createElement('input');
    input.type = (q.type === 'single') ? 'radio' : 'checkbox';
    input.name = 'opts';
    input.value = opt.key;
    input.className = 'checkbox';
    const saved = selections[q.id] || [];
    if(saved.includes(opt.key)) input.checked = true;
    label.appendChild(input);
    label.appendChild(document.createTextNode(` ${opt.key}. ${opt.text}`));
    optWrap.appendChild(label);
  });

  document.getElementById('progress').textContent = `${idx+1} of ${VIEW.length}`;
  setFeedback('');
  document.getElementById('continueBtn').disabled = true;
}

function runSearchFilter(){
  const qStr = (document.getElementById('search')?.value || '').trim().toLowerCase();
  const merged = mergeAdded(); // include added questions
  if(!qStr){ QUESTIONS = merged; idx = 0; render(); return; }
  QUESTIONS = merged.filter(item => {
    const optsText = (Array.isArray(item.options) ? item.options.map(o=>o.text)
                    : Object.values(item.options||{})).join(' ');
    return (item.stem + ' ' + optsText).toLowerCase().includes(qStr);
  });
  idx = 0; render();
}

// Manual search button
bind('applySearch','click', runSearchFilter);

// Clear search button
bind('clearSearch','click', () => {
  const s = document.getElementById('search');
  if (s) s.value = '';
  runSearchFilter();
});


// My Review (‚≠ê + üö©)
bind('showReview','click', (e) => {
  e.preventDefault();
  filterReviewOnly = true;
  idx = 0;
  render();
});

// All Questions
bind('showAll','click', (e) => {
  e.preventDefault();
  filterReviewOnly = false;
  idx = 0;
  render();
});

// Check current answer
bind('checkBtn','click', () => {
  const q = QUESTIONS[idx];
  const selected = Array.from(document.querySelectorAll('input[name="opts"]:checked')).map(i=>i.value).sort();
  const correct = [...q.correct].sort();

  if (JSON.stringify(selected) === JSON.stringify(correct)) {
    setFeedback('‚úÖ Correct!', 'correct');
    document.getElementById('continueBtn').disabled = false;
    if (isFlagged(q.id)) unflagWrong(q.id);
    document.getElementById('qtitle').textContent = `${q.id}  ${q.stem}`; // remove üö© immediately
  } else {
    setFeedback('‚ùå Try again', 'wrong');
    flagWrong(q.id);
    document.getElementById('qtitle').textContent = `${q.id} üö©  ${q.stem}`; // show üö© immediately
  }
});

// ‚≠ê Flag for review (your own toggle)
bind('flagBtn','click', () => {
  const q = QUESTIONS[idx];
  if (!q) return;
  if (!flaggedByUser.includes(q.id)) {
    flaggedByUser.push(q.id);
    setFeedback('‚≠ê Added to My Review');
  } else {
    flaggedByUser = flaggedByUser.filter(id => id !== q.id);
    setFeedback('‚≠ê Removed from My Review');
  }
  localStorage.setItem('user_flags', JSON.stringify(flaggedByUser));
  render();
});



// Reveal answer (inline)
bind('showAnsBtn','click', () => {
  const q = QUESTIONS[idx];
  if (!q || !q.correct) {
    setFeedback('No correct answer stored for this question.', 'wrong');
    return;
  }
  const ans = Array.isArray(q.correct) ? q.correct.join(', ') : String(q.correct);
  setFeedback('Answer: ' + ans, 'correct');
});

// Save selection for later (only binds if button exists)
bind('saveBtn','click', () => {
  const q = QUESTIONS[idx];
  const selected = Array.from(document.querySelectorAll('input[name="opts"]:checked')).map(i=>i.value);
  selections[q.id] = selected;
  localStorage.setItem('mcqSelections', JSON.stringify(selections));
  setFeedback('üíæ Saved for later on this device.');
  setTimeout(()=> setFeedback(''), 1200);
});

// Navigation
bind('continueBtn','click', () => { goNext(); });
bind('prevBtn','click', () => { if(idx>0){ idx--; render(); }});
bind('nextBtn','click', () => { goNext(); });
bind('jumpStartBtn','click', () => { idx = 0; render(); });
bind('jumpEndBtn','click', () => { idx = QUESTIONS.length-1; render(); });

// Review only üö© wrong (site flags)
bind('reviewWrongBtn','click', () => {
  const set = new Set(wrong || []);
  if (set.size === 0) {
    setFeedback('No flagged questions yet. Answer one incorrectly to flag it.', '');
    return;
  }
  const merged = mergeAdded();
  QUESTIONS = merged.filter(q => set.has(q.id));
  idx = 0;
  render();
  setFeedback(`Reviewing ${QUESTIONS.length} flagged question(s).`, '');
});

// Back to full set
bind('showAllBtn','click', () => {
  QUESTIONS = mergeAdded();
  idx = 0;
  render();
  setFeedback('Showing all questions.', '');
});

// Clear all üö© flags (optional button)
bind('clearFlagsBtn','click', () => {
  if (!wrong || wrong.length === 0) { setFeedback('No flags to clear.', ''); return; }
  const ok = confirm(`Clear ${wrong.length} flagged question(s)?`);
  if (!ok) return;
  wrong = [];
  localStorage.setItem('wrong_ids', JSON.stringify(wrong));
  setFeedback('All flags cleared.', '');
  render(); // refresh current title to remove üö© if shown
});

function goNext(){
  if(idx < QUESTIONS.length-1){ idx++; render(); }
  else { setFeedback("üéâ You've reached the end.", 'correct'); }
}

function loadSelections(){
  try{ return JSON.parse(localStorage.getItem('mcqSelections') || '{}'); }catch(e){ return {}; }
}
(function initClock(){
  const clock = document.getElementById('clock');
  const upd = ()=>{
    const d = new Date();
    const pad = n => n.toString().padStart(2,'0');
    clock.textContent = `${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };
  upd(); setInterval(upd, 10000);
})();
// --- Error reporting and editing feature ---
let reports = JSON.parse(localStorage.getItem('reports') || '[]');
let edits = JSON.parse(localStorage.getItem('edits') || '{}');

document.getElementById('reportBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  const reason = prompt("Describe the error (stem/options/answer mismatch):");
  if(reason){
    reports.push({id:q.id, stem:q.stem, reason});
    localStorage.setItem('reports', JSON.stringify(reports));
    alert("Error reported and saved locally.");
  }
});
document.getElementById('editBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  const ed = document.getElementById('editor');
  ed.style.display = 'block';

  // Fill fields
  document.getElementById('editStem').value = q.stem || '';
  document.getElementById('editType').value = (q.type === 'multi' ? 'multi' : 'single');

  // Support both array/object option shapes
  const optsArray = Array.isArray(q.options)
    ? q.options
    : Object.keys(q.options || {}).map(k => ({ key: k, text: String(q.options[k]) }));

  document.getElementById('editOptions').value =
    optsArray.map(o => `${o.key}. ${o.text}`).join('\n');

  document.getElementById('editCorrect').value = (q.correct || []).join(',');
});


document.getElementById('cancelEditBtn').addEventListener('click', () => {
  document.getElementById('editor').style.display = 'none';
});

document.getElementById('saveEditBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];

  // Stem & Type
  q.stem = document.getElementById('editStem').value.trim();
  q.type = document.getElementById('editType').value;

  // Options: parse each line like "a. text"
  const optsLines = document.getElementById('editOptions').value
    .split('\n').map(l => l.trim()).filter(Boolean);

  const options = [];
  for (const line of optsLines) {
    const m = line.match(/^([a-e])\.\s*(.+)$/i);
    if (!m) { alert('Each option must look like "a. text" (a‚Äìe).'); return; }
    options.push({ key: m[1].toLowerCase(), text: m[2] });
  }
  q.options = options;

  // Correct letters
  let corr = document.getElementById('editCorrect').value
    .split(',').map(x => x.trim().toLowerCase()).filter(Boolean);

  // If user chose single but entered multiple, keep only first
  if (q.type === 'single' && corr.length > 1) {
    alert('Type is single; keeping only the first correct option.');
    corr = [corr[0]];
  }
  q.correct = corr;

  // Persist local edits
  edits[q.id] = q;
  localStorage.setItem('edits', JSON.stringify(edits));

  alert('Edits saved locally.');
  document.getElementById('editor').style.display = 'none';
  render(); // re-render with edits
});


// Apply edits when rendering
const oldRender = render;
render = function(){
  const q = QUESTIONS[idx];
  if (q && edits && edits[q.id]) {
    Object.assign(q, edits[q.id]);
  }
  // normalize options so both array and object shapes render
  if (q && !Array.isArray(q.options) && q.options && typeof q.options === 'object') {
    q.options = Object.keys(q.options).sort().map(k => ({key:k, text:String(q.options[k])}));
  }
  oldRender();
};
  // ----- Add-new-question feature -----
let added = JSON.parse(localStorage.getItem('added_questions') || '[]');

// merge added questions after the JSON loads
// (put this right after you set ALL = data; QUESTIONS = ALL;)
  function romanToInt(s){
  if(!s) return 0;
  const map = {I:1,V:5,X:10,L:50,C:100,D:500,M:1000};
  let total=0, prev=0; s=s.toUpperCase();
  for(let i=s.length-1;i>=0;i--){
    const v = map[s[i]]||0;
    total += (v<prev)?-v:v;
    prev = v;
  }
  return total;
}
function sortById(a,b){
  const pa = String(a.id||'').split('.');
  const pb = String(b.id||'').split('.');
  const A = /^\d+$/.test(pa[0]) ? parseInt(pa[0],10) : romanToInt(pa[0]);
  const B = /^\d+$/.test(pb[0]) ? parseInt(pb[0],10) : romanToInt(pb[0]);
  const a2 = parseInt(pa[1]||'0',10);
  const b2 = parseInt(pb[1]||'0',10);
  return (A-B) || (a2-b2);
}
function mergeAdded() {
  if (!Array.isArray(added)) added = [];
  // dedupe by id (added overrides base if same id)
  const byId = new Map();
  ALL.forEach(q => q && q.id && byId.set(q.id, q));
  added.forEach(q => q && q.id && byId.set(q.id, q));
  // create merged + natural sort
  const merged = Array.from(byId.values()).sort(sortById);
  QUESTIONS = merged;
  return merged; // handy for search
}
 // hook into your fetch then(...) where you currently have: 
 // .then(data => { ALL = data; QUESTIONS = ALL; render(); })
 // change to:
 // .then(data => { ALL = data; QUESTIONS = ALL; mergeAdded(); render(); })

// open the new-question panel
document.getElementById('addQBtn').addEventListener('click', () => {
  document.getElementById('newQ').style.display = 'block';
  // sensible defaults
  document.getElementById('newQId').value = '';
  document.getElementById('newQStem').value = '';
  document.getElementById('newQType').value = 'single';
  document.getElementById('newQOptions').value = 'a. \nb. \nc. \nd. \ne. ';
  document.getElementById('newQCorrect').value = '';
});

// cancel
document.getElementById('cancelNewQBtn').addEventListener('click', () => {
  document.getElementById('newQ').style.display = 'none';
});

// save
document.getElementById('saveNewQBtn').addEventListener('click', () => {
  const id = document.getElementById('newQId').value.trim();
  const stem = document.getElementById('newQStem').value.trim();
  const type = document.getElementById('newQType').value;
  const optsLines = document.getElementById('newQOptions').value.split('\n').map(s=>s.trim()).filter(Boolean);
  const correct = document.getElementById('newQCorrect').value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);

  if(!id || !stem || optsLines.length < 2 || correct.length === 0){
    alert('Please fill ID, stem, at least 2 options, and at least 1 correct letter.');
    return;
  }

  // parse options like "a. text"
  const options = [];
  for(const line of optsLines){
    const m = line.match(/^([a-e])\.\s*(.+)$/i);
    if(!m){ alert('Options must look like "a. text"'); return; }
    options.push({ key: m[1].toLowerCase(), text: m[2] });
  }

  const q = { id, stem, type, options, correct };

  // prevent duplicate IDs with existing content
  const existsInAll = QUESTIONS.some(x => x.id === id);
  if(existsInAll){
    const ok = confirm('A question with this ID exists. Add anyway as a new item?');
    if(!ok) return;
  }

  added.push(q);
  localStorage.setItem('added_questions', JSON.stringify(added));

  // add to in-memory list so it appears immediately
  QUESTIONS.push(q);

  alert('New question saved (locally). It will appear in search and navigation.');
  document.getElementById('newQ').style.display = 'none';
  // jump to the new question
  idx = QUESTIONS.length - 1;
  render();
});
  document.getElementById('exportBtn').addEventListener('click', () => {
  const data = {
    reports: reports,
    edits: edits,
    added: added || []
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'corrections.json';
  a.click();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>
